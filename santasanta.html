<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Secret Santa Wheel üéÑ</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Mountains+of+Christmas:wght@700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);
    background-size: 400% 400%;
    animation: gradientShift 15s ease infinite;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    color: #333;
  }

  @keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }

  .container {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 24px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.5);
    padding: 40px;
    max-width: 600px;
    width: 100%;
    text-align: center;
    position: relative;
    overflow: hidden;
  }

  .container::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255, 215, 0, 0.1) 0%, transparent 70%);
    animation: shimmer 3s ease-in-out infinite;
  }

  @keyframes shimmer {
    0%, 100% { transform: rotate(0deg); }
    50% { transform: rotate(180deg); }
  }

  h1 {
    font-family: 'Mountains of Christmas', serif;
    font-size: 2.5rem;
    color: #c41e3a;
    margin-bottom: 10px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    position: relative;
    z-index: 1;
  }

  .subtitle {
    color: #666;
    margin-bottom: 30px;
    font-size: 0.95rem;
    position: relative;
    z-index: 1;
  }

  .input-group {
    margin-bottom: 30px;
    position: relative;
    z-index: 1;
  }

  label {
    display: block;
    margin-bottom: 10px;
    color: #555;
    font-weight: 600;
    font-size: 0.95rem;
  }

  .input-wrapper {
    position: relative;
    display: inline-block;
    width: 100%;
    max-width: 300px;
  }

  input[type="text"] {
    width: 100%;
    padding: 14px 20px;
    font-size: 1rem;
    border: 2px solid #e0e0e0;
    border-radius: 12px;
    outline: none;
    transition: all 0.3s ease;
    font-family: 'Poppins', sans-serif;
    background: white;
  }

  input[type="text"]:focus {
    border-color: #c41e3a;
    box-shadow: 0 0 0 4px rgba(196, 30, 58, 0.1);
  }

  input[type="text"]:disabled {
    background: #f5f5f5;
    cursor: not-allowed;
  }

  .wheel-container {
    position: relative;
    display: inline-block;
    margin: 30px 0;
    filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.2));
  }

  canvas {
    display: block;
    border-radius: 50%;
    background: white;
    transition: transform 0.1s ease-out;
  }

  canvas.spinning {
    animation: wheelPulse 0.5s ease-in-out infinite;
  }

  @keyframes wheelPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
  }

  .pointer {
    position: absolute;
    top: -15px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 15px solid transparent;
    border-right: 15px solid transparent;
    border-top: 30px solid #c41e3a;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    z-index: 10;
  }

  .pointer::after {
    content: '';
    position: absolute;
    top: -35px;
    left: -5px;
    width: 10px;
    height: 10px;
    background: #c41e3a;
    border-radius: 50%;
    box-shadow: 0 0 10px rgba(196, 30, 58, 0.5);
  }

  button {
    padding: 14px 32px;
    font-size: 1rem;
    font-weight: 600;
    font-family: 'Poppins', sans-serif;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
  }

  button::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.3);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
  }

  button:hover::before {
    width: 300px;
    height: 300px;
  }

  button:active {
    transform: scale(0.98);
  }

  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }

  button:disabled::before {
    display: none;
  }

  .btn-primary {
    background: linear-gradient(135deg, #c41e3a 0%, #e63946 100%);
    color: white;
  }

  .btn-primary:hover:not(:disabled) {
    background: linear-gradient(135deg, #a01a2e 0%, #c41e3a 100%);
    box-shadow: 0 6px 20px rgba(196, 30, 58, 0.4);
  }

  .btn-secondary {
    background: linear-gradient(135deg, #2d8659 0%, #4caf50 100%);
    color: white;
    margin-top: 15px;
  }

  .btn-secondary:hover:not(:disabled) {
    background: linear-gradient(135deg, #1f5d3f 0%, #2d8659 100%);
    box-shadow: 0 6px 20px rgba(45, 134, 89, 0.4);
  }

  .spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-right: 8px;
    vertical-align: middle;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  #result {
    margin-top: 25px;
    min-height: 60px;
    font-size: 1.1rem;
    font-weight: 600;
    position: relative;
    z-index: 1;
  }

  .message {
    padding: 15px 20px;
    border-radius: 12px;
    margin-top: 15px;
    font-weight: 500;
    animation: slideIn 0.3s ease-out;
  }

  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .message.success {
    background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
    color: #155724;
    border: 2px solid #28a745;
  }

  .message.error {
    background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
    color: #721c24;
    border: 2px solid #dc3545;
  }

  .message.info {
    background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
    color: #0c5460;
    border: 2px solid #17a2b8;
  }

  .celebration {
    animation: celebrate 0.6s ease-out;
  }

  @keyframes celebrate {
    0%, 100% { transform: scale(1); }
    25% { transform: scale(1.1) rotate(-5deg); }
    75% { transform: scale(1.1) rotate(5deg); }
  }

  .confetti {
    position: fixed;
    width: 10px;
    height: 10px;
    background: #c41e3a;
    position: absolute;
    animation: confettiFall 3s ease-out forwards;
  }

  @keyframes confettiFall {
    to {
      transform: translateY(100vh) rotate(720deg);
      opacity: 0;
    }
  }

  @media (max-width: 600px) {
    .container {
      padding: 25px 20px;
    }

    h1 {
      font-size: 2rem;
    }

    canvas {
      width: 100%;
      max-width: 350px;
      height: auto;
    }

    button {
      width: 100%;
      max-width: 300px;
    }
  }

  .loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 24px;
    z-index: 100;
  }

  .loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid #e0e0e0;
    border-top-color: #c41e3a;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
</style>
</head>

<body>
<div class="container">
  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="loading-spinner"></div>
  </div>

  <h1>üéÑ Secret Santa Wheel üéÅ</h1>
  <p class="subtitle">Enter your name and spin to discover your Secret Santa match!</p>

  <div class="input-group">
    <label for="userName">Your Name</label>
    <div class="input-wrapper">
      <input type="text" id="userName" placeholder="Enter your name" autocomplete="name">
    </div>
  </div>

  <div class="wheel-container">
    <div class="pointer"></div>
    <canvas id="wheelCanvas" width="500" height="500"></canvas>
  </div>

  <button id="spinBtn" class="btn-primary" disabled>
    <span id="spinBtnText">Spin the Wheel üé°</span>
  </button>

  <div id="result"></div>
</div>

<script>
// ===== SUPABASE CONFIGURATION =====
const SUPABASE_URL = "https://endkiekuvqftqdbvblkr.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVuZGtpZWt1dnFmdHFkYnZibGtyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjYwODAwNjgsImV4cCI6MjA4MTY1NjA2OH0.6V2mObkCRC_jCOGa6s0cTdYtO3n7j_lEPAlgwNvokzc";

// Initialize Supabase client (access via window to avoid declaration conflicts)
const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// ===== STATE MANAGEMENT =====
let participants = [];
let spinning = false;
let hasSpun = false;
let spinnerName = "";
let resultName = "";
let currentAngle = 0;

// ===== CANVAS SETUP =====
const canvas = document.getElementById("wheelCanvas");
const ctx = canvas.getContext("2d");
const centerX = canvas.width / 2;
const centerY = canvas.height / 2;
const radius = Math.min(centerX, centerY) - 20;

// High-quality rendering
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = "high";

// ===== COLOR PALETTE =====
const colors = [
  "#c41e3a", // Deep red
  "#2d8659", // Forest green
  "#d4af37", // Gold
  "#e63946", // Bright red
  "#4caf50", // Green
  "#ff6b35", // Orange
  "#7209b7", // Purple
  "#f77f00", // Dark orange
  "#06a77d", // Teal
  "#d62828"  // Crimson
];

// ===== UI HELPERS =====
function showLoading(show = true) {
  document.getElementById("loadingOverlay").style.display = show ? "flex" : "none";
}

function showMessage(text, type = "info") {
  const resultDiv = document.getElementById("result");
  resultDiv.innerHTML = `<div class="message ${type}">${text}</div>`;
}

function showError(text) {
  showMessage(text, "error");
}

function showSuccess(text) {
  const resultDiv = document.getElementById("result");
  showMessage(text, "success");
  resultDiv.classList.add("celebration");
  setTimeout(() => resultDiv.classList.remove("celebration"), 600);
}

function updateSpinButton(enabled, text = null) {
  const btn = document.getElementById("spinBtn");
  const btnText = document.getElementById("spinBtnText");
  btn.disabled = !enabled;
  if (text) {
    btnText.innerHTML = enabled ? text : `<span class="spinner"></span>${text}`;
  }
}

// ===== DRAW POINTER =====
function drawPointer() {
  const pointerY = centerY - radius - 10;
  const pointerSize = 20;

  // Shadow
  ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
  ctx.shadowBlur = 8;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 2;

  // Pointer triangle
  ctx.fillStyle = "#c41e3a";
  ctx.beginPath();
  ctx.moveTo(centerX - pointerSize, pointerY);
  ctx.lineTo(centerX + pointerSize, pointerY);
  ctx.lineTo(centerX, pointerY + pointerSize + 5);
  ctx.closePath();
  ctx.fill();

  // Reset shadow
  ctx.shadowColor = "transparent";
  ctx.shadowBlur = 0;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;

  // Center dot
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(centerX, pointerY + 5, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#c41e3a";
  ctx.beginPath();
  ctx.arc(centerX, pointerY + 5, 4, 0, Math.PI * 2);
  ctx.fill();
}

// ===== DRAW WHEEL =====
function drawWheel() {
  if (participants.length === 0) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#666";
    ctx.font = "bold 24px Poppins";
    ctx.textAlign = "center";
    ctx.fillText("Loading participants...", centerX, centerY);
    return;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const arc = (2 * Math.PI) / participants.length;

  // Draw segments
  for (let i = 0; i < participants.length; i++) {
    const angle = currentAngle + i * arc;
    const color = colors[i % colors.length];

    // Create gradient for each segment
    const gradient = ctx.createRadialGradient(
      centerX, centerY, 0,
      centerX, centerY, radius
    );
    gradient.addColorStop(0, lightenColor(color, 20));
    gradient.addColorStop(1, color);

    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.arc(centerX, centerY, radius, angle, angle + arc);
    ctx.closePath();
    ctx.fillStyle = gradient;
    ctx.fill();

    // Segment border
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 3;
    ctx.stroke();

    // Text
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(angle + arc / 2);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    // Text shadow for readability
    ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
    ctx.shadowBlur = 6;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;

    ctx.fillStyle = "#fff";
    ctx.font = "bold 20px 'Poppins', sans-serif";
    
    // Position text in the middle of the segment, closer to the edge
    const textRadius = radius - 40;
    const text = participants[i];
    
    // Draw text with better positioning
    ctx.fillText(text, textRadius, 0);
    
    // Also draw a stroke for better visibility
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 1;
    ctx.strokeText(text, textRadius, 0);

    ctx.restore();
  }

  // Center circle
  const centerGradient = ctx.createRadialGradient(
    centerX, centerY, 0,
    centerX, centerY, 30
  );
  centerGradient.addColorStop(0, "#fff");
  centerGradient.addColorStop(1, "#e0e0e0");
  ctx.beginPath();
  ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
  ctx.fillStyle = centerGradient;
  ctx.fill();
  ctx.strokeStyle = "#c41e3a";
  ctx.lineWidth = 4;
  ctx.stroke();

  drawPointer();
}

function lightenColor(color, percent) {
  const num = parseInt(color.replace("#", ""), 16);
  const r = Math.min(255, (num >> 16) + percent);
  const g = Math.min(255, ((num >> 8) & 0x00FF) + percent);
  const b = Math.min(255, (num & 0x0000FF) + percent);
  return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, "0")}`;
}

// ===== FETCH PARTICIPANTS =====
async function fetchParticipants() {
  try {
    showLoading(true);
    const { data, error } = await supabaseClient
      .from("participants")
      .select("name")
      .order("name");

    if (error) throw error;

    if (!data || data.length === 0) {
      showError("No participants found. Please add participants to the database.");
      return;
    }

    participants = data.map(p => p.name);
    // Force redraw after participants are loaded
    setTimeout(() => {
      drawWheel();
      showMessage(`Loaded ${participants.length} participant${participants.length !== 1 ? "s" : ""}.`, "info");
    }, 100);
  } catch (error) {
    console.error("Error fetching participants:", error);
    showError(`Failed to load participants: ${error.message}`);
  } finally {
    showLoading(false);
  }
}

// ===== CLEAR STATUS MESSAGES =====
function clearStatus() {
  const resultDiv = document.getElementById("result");
  resultDiv.innerHTML = "";
}

// ===== HANDLE INPUT CHANGE =====
function handleInputChange() {
  spinnerName = document.getElementById("userName").value.trim();
  
  // Clear any error messages immediately
  clearStatus();
  
  // Disable spin button if input is empty or already spun
  if (!spinnerName || hasSpun) {
    updateSpinButton(false);
  } else {
    // Enable button if name is entered and not yet spun
    // Supabase will validate the name when spinning
    updateSpinButton(true);
  }
}

// ===== SPIN WHEEL =====
async function spinWheel() {
  // Prevent double spins
  if (spinning || hasSpun) {
    return;
  }
  
  // Get and trim current input value
  spinnerName = document.getElementById("userName").value.trim();
  
  // Basic validation - only check if name is entered
  if (!spinnerName) {
    showError("Please enter your name.");
    return;
  }

  // Clear any previous messages
  clearStatus();

  // Prevent double clicks
  spinning = true;
  updateSpinButton(false, "Spinning...");
  canvas.classList.add("spinning");

  try {
    // Call Supabase RPC function with spinnerName
    // Supabase is the single source of truth for validation
    const { data, error } = await supabaseClient.rpc("draw_santa", {
      user_name: spinnerName
    });

    if (error) {
      console.error("Supabase RPC error:", error);
      canvas.classList.remove("spinning");
      spinning = false;
      
      // Parse Supabase error messages
      const errorMessage = error.message || error.details || String(error);
      let userMessage = "An error occurred. Please try again.";
      
      // Handle specific error cases
      if (errorMessage.toLowerCase().includes("not found") || 
          errorMessage.toLowerCase().includes("does not exist") ||
          errorMessage.toLowerCase().includes("invalid") ||
          error.code === "P0001") {
        userMessage = "Name not found in participants list. Please check your spelling.";
      } else if (errorMessage.toLowerCase().includes("already") || 
                 errorMessage.toLowerCase().includes("used") ||
                 errorMessage.toLowerCase().includes("spun")) {
        userMessage = "You have already spun the wheel. Each person can only spin once.";
        hasSpun = true;
        updateSpinButton(false, "Already Spun");
        document.getElementById("userName").disabled = true;
      } else {
        userMessage = errorMessage;
      }
      
      showError(userMessage);
      if (!hasSpun) {
        updateSpinButton(true);
      }
      return;
    }

    console.log("RPC response data:", data);

    // Handle different response formats - extract resultName from Supabase
    resultName = null;
    if (!data) {
      throw new Error("No result returned from server.");
    } else if (typeof data === 'string') {
      // If RPC returns a string directly
      resultName = data;
    } else if (data.name) {
      // If RPC returns an object with a name property
      resultName = data.name;
    } else if (Array.isArray(data) && data.length > 0) {
      // If RPC returns an array, take the first element
      resultName = data[0].name || data[0];
    } else {
      throw new Error(`Unexpected response format from server: ${JSON.stringify(data)}`);
    }

    if (!resultName || typeof resultName !== 'string' || resultName.trim() === '') {
      throw new Error("No valid result returned from server.");
    }

    // Trim and normalize resultName
    resultName = resultName.trim();

    // Find index of resultName in participants (wheel contains ALL participants)
    const resultIndex = participants.findIndex(
      p => p.toLowerCase() === resultName.toLowerCase()
    );

    if (resultIndex === -1) {
      // This should not happen if Supabase is working correctly
      // But handle gracefully
      console.error(`Result name "${resultName}" not found in participants list.`);
      throw new Error(`Server returned an invalid result. Please contact support.`);
    }

    // Calculate target angle based on resultName index
    // Pointer is at top (-œÄ/2), so segment center must align with pointer
    // Segment i starts at: currentAngle + i * arc
    // Segment i center is at: currentAngle + i * arc + arc/2
    // For resultIndex to be under pointer: currentAngle + resultIndex * arc + arc/2 = -œÄ/2
    // Therefore: currentAngle = -œÄ/2 - resultIndex * arc - arc/2
    const arc = (2 * Math.PI) / participants.length;
    const pointerAngle = -Math.PI / 2; // Pointer is at top (12 o'clock)
    
    // Calculate target angle so that segment resultIndex's center aligns with pointer
    // We want: finalAngle + resultIndex * arc + arc/2 = pointerAngle
    // So: finalAngle = pointerAngle - resultIndex * arc - arc/2
    const targetAngle = pointerAngle - resultIndex * arc - arc / 2;
    
    // Debug logging
    console.log(`Result: ${resultName}, Index: ${resultIndex}, Participants: [${participants.join(', ')}], Target angle: ${targetAngle}, Arc: ${arc}`);

    // Animate to target
    // Normalize current angle to [0, 2œÄ)
    const normalizedCurrent = ((currentAngle % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
    // Normalize target angle to [0, 2œÄ)
    const normalizedTarget = ((targetAngle % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
    
    // Calculate the shortest rotation to target
    let angleDiff = normalizedTarget - normalizedCurrent;
    if (angleDiff < 0) {
      angleDiff += 2 * Math.PI;
    }
    
    // Add multiple full rotations for visual effect
    const spins = 5 + Math.random() * 2; // 5-7 full rotations
    const totalRotation = spins * 2 * Math.PI + angleDiff;

    const duration = 4000;
    const startTime = performance.now();
    const startAngle = currentAngle;

    function animate(time) {
      const elapsed = Math.min(time - startTime, duration);
      const progress = elapsed / duration;

      // Quartic easing for smooth deceleration
      const ease = 1 - Math.pow(1 - progress, 4);

      currentAngle = startAngle + totalRotation * ease;
      drawWheel();

      if (elapsed < duration) {
        requestAnimationFrame(animate);
      } else {
        // Ensure final angle is exactly correct (account for floating point errors)
        const finalArc = (2 * Math.PI) / participants.length;
        const exactTargetAngle = pointerAngle - resultIndex * finalArc - finalArc / 2;
        currentAngle = exactTargetAngle;
        drawWheel();
        
        // Verify which segment is actually under the pointer
        const verifyArc = (2 * Math.PI) / participants.length;
        const normalizedFinal = ((currentAngle % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
        const pointerAngleNorm = ((pointerAngle % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
        
        for (let i = 0; i < participants.length; i++) {
          const segCenter = ((normalizedFinal + i * verifyArc + verifyArc / 2) % (2 * Math.PI));
          let diff = Math.abs(segCenter - pointerAngleNorm);
          if (diff > Math.PI) diff = 2 * Math.PI - diff;
          if (diff < verifyArc / 4) {
            console.log(`Final check: Pointer at segment ${i} (${participants[i]}), Expected: ${resultIndex} (${resultName})`);
            if (i !== resultIndex) {
              console.error(`MISMATCH! Adjusting angle...`);
              // Force correct alignment
              currentAngle = pointerAngle - resultIndex * verifyArc - verifyArc / 2;
              drawWheel();
            }
            break;
          }
        }
        
        // Animation complete - display resultName (never spinnerName)
        canvas.classList.remove("spinning");
        hasSpun = true;
        spinning = false;
        showSuccess(`üéâ Congratulations! You got: <strong>${resultName}</strong> üéÅ`);
        updateSpinButton(false, "Already Spun");
        
        // Disable input to prevent changes after successful spin
        document.getElementById("userName").disabled = true;
        
        // Celebration effect
        createConfetti();
      }
    }

    requestAnimationFrame(animate);

  } catch (error) {
    console.error("Error spinning wheel:", error);
    canvas.classList.remove("spinning");
    spinning = false;
    
    // Handle unexpected errors
    const errorMessage = error.message || String(error);
    
    if (errorMessage.toLowerCase().includes("already") || 
        errorMessage.toLowerCase().includes("used") ||
        errorMessage.toLowerCase().includes("spun")) {
      hasSpun = true;
      showError("You have already spun the wheel. Each person can only spin once.");
      updateSpinButton(false, "Already Spun");
      document.getElementById("userName").disabled = true;
    } else {
      showError(errorMessage || "An error occurred. Please try again.");
      updateSpinButton(true);
    }
  }
}

// ===== CELEBRATION EFFECT =====
function createConfetti() {
  const colors = ["#c41e3a", "#2d8659", "#d4af37", "#e63946", "#4caf50"];
  for (let i = 0; i < 30; i++) {
    setTimeout(() => {
      const confetti = document.createElement("div");
      confetti.className = "confetti";
      confetti.style.left = Math.random() * 100 + "%";
      confetti.style.top = "-10px";
      confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.width = Math.random() * 10 + 5 + "px";
      confetti.style.height = confetti.style.width;
      document.body.appendChild(confetti);
      setTimeout(() => confetti.remove(), 3000);
    }, i * 50);
  }
}

// ===== EVENT LISTENERS =====
document.getElementById("userName").addEventListener("input", handleInputChange);
document.getElementById("userName").addEventListener("keypress", (e) => {
  if (e.key === "Enter" && !document.getElementById("spinBtn").disabled) {
    spinWheel();
  }
});

document.getElementById("spinBtn").addEventListener("click", spinWheel);

// ===== INITIALIZE =====
// Wait for fonts to load before drawing
document.fonts.ready.then(() => {
  fetchParticipants();
  drawWheel();
}).catch(() => {
  // Fallback if font loading fails
  fetchParticipants();
  drawWheel();
});

// Redraw on window resize for responsive canvas
let resizeTimeout;
window.addEventListener("resize", () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    drawWheel();
  }, 250);
});
</script>

</body>
</html>
